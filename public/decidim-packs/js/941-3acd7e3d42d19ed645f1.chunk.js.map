{"version":3,"file":"js/941-3acd7e3d42d19ed645f1.chunk.js","mappings":"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","sources":["webpack://app/./node_modules/@graphiql/react/dist/Range.es.js","webpack://app/./node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","webpack://app/./node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","webpack://app/./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","webpack://app/./node_modules/graphql/validation/specifiedRules.mjs","webpack://app/./node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","webpack://app/./node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","webpack://app/./node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","webpack://app/./node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","webpack://app/./node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","webpack://app/./node_modules/graphql/validation/ValidationContext.mjs","webpack://app/./node_modules/graphql/validation/validate.mjs","webpack://app/./node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","webpack://app/./node_modules/@graphiql/react/dist/lint.es.js"],"sourcesContent":["class CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match && match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\nexport { CharacterStream as C, Position as P, Range as R };\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isExecutableDefinitionNode } from \"../../language/predicates.mjs\";\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document: function Document(node) {\n      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {\n        var definition = _node$definitions2[_i2];\n\n        if (!isExecutableDefinitionNode(definition)) {\n          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : '\"' + definition.name.value + '\"';\n          context.reportError(new GraphQLError(\"The \".concat(defName, \" definition is not executable.\"), definition));\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new GraphQLError(\"Unknown fragment \\\"\".concat(fragmentName, \"\\\".\"), node.name));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\nexport function NoUnusedFragmentsRule(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {\n          var operation = operationDefs[_i2];\n\n          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {\n            var fragment = _context$getRecursive2[_i4];\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {\n          var fragmentDef = fragmentDefs[_i6];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" is never used.\"), fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\nexport function KnownArgumentNamesRule(context) {\n  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        var suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(parentType.name, \".\").concat(fieldDef.name, \"\\\".\") + didYouMean(suggestions), argNode));\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    directiveArgs[directive.name] = directive.args.map(function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map(function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {\n          var argNode = _directiveNode$argume2[_i6];\n          var argName = argNode.name.value;\n\n          if (knownArgs.indexOf(argName) === -1) {\n            var suggestions = suggestionList(argName, knownArgs);\n            context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\") + didYouMean(suggestions), argNode));\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import objectValues from \"../../polyfills/objectValues.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType, isRequiredInputField, getNullableType, getNamedType } from \"../../type/definition.mjs\";\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var fieldNodeMap = keyMap(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n        var fieldDef = _objectValues2[_i2];\n        var fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          var typeStr = inspect(fieldDef.type);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldDef.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\"), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = getNamedType(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(node.name.value, \"\\\" is not defined by type \\\"\").concat(parentType.name, \"\\\".\") + didYouMean(suggestions), node));\n      }\n    },\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(inspect(type), \"\\\", found \").concat(print(node), \".\"), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      return isValidValueNode(context, node);\n    },\n    IntValue: function IntValue(node) {\n      return isValidValueNode(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidValueNode(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidValueNode(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidValueNode(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    var typeStr = inspect(locationType);\n    context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      var _typeStr = inspect(locationType);\n\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    }\n  } catch (error) {\n    var _typeStr2 = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr2, \"\\\", found \").concat(print(node), \"; \") + error.message, node, undefined, undefined, undefined, error));\n    }\n  }\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\nimport { isType, isRequiredArgument } from \"../../type/definition.mjs\";\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n        var argNodeMap = keyMap(argNodes, function (arg) {\n          return arg.name.value;\n        });\n\n        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {\n          var argDef = _fieldDef$args2[_i2];\n          var argNode = argNodeMap[argDef.name];\n\n          if (!argNode && isRequiredArgument(argDef)) {\n            var argTypeStr = inspect(argDef.type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {\n    var directive = definedDirectives[_i4];\n    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {\n    var def = astDefinitions[_i6];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n\n          var argNodeMap = keyMap(_argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {\n            var argName = _Object$keys2[_i8];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              var argTypeStr = isType(argType) ? inspect(argType) : print(argType);\n              context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isNonNullType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { isTypeSubTypeOf } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Variables passed to field arguments conform to type\n */\nexport function VariablesInAllowedPositionRule(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var type = _ref2.type;\n          var defaultValue = _ref2.defaultValue;\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = typeFromAST(schema, varDef.type);\n\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n              var varTypeStr = inspect(varType);\n              var typeStr = inspect(type);\n              context.reportError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varTypeStr, \"\\\" used in position expecting type \\\"\").concat(typeStr, \"\\\".\"), [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","import find from \"../../polyfills/find.mjs\";\nimport objectEntries from \"../../polyfills/objectEntries.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = objectEntries(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    this._pairSetAdd(a, b, areMutuallyExclusive);\n\n    this._pairSetAdd(b, a, areMutuallyExclusive);\n  };\n\n  _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {\n    var map = this._data[a];\n\n    if (!map) {\n      map = Object.create(null);\n      this._data[a] = map;\n    }\n\n    map[b] = areMutuallyExclusive;\n  };\n\n  return PairSet;\n}();\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from \"./rules/ExecutableDefinitionsRule.mjs\"; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from \"./rules/UniqueOperationNamesRule.mjs\"; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from \"./rules/LoneAnonymousOperationRule.mjs\"; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from \"./rules/SingleFieldSubscriptionsRule.mjs\"; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from \"./rules/KnownTypeNamesRule.mjs\"; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from \"./rules/FragmentsOnCompositeTypesRule.mjs\"; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from \"./rules/VariablesAreInputTypesRule.mjs\"; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from \"./rules/ScalarLeafsRule.mjs\"; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from \"./rules/FieldsOnCorrectTypeRule.mjs\"; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from \"./rules/UniqueFragmentNamesRule.mjs\"; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from \"./rules/KnownFragmentNamesRule.mjs\"; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from \"./rules/NoUnusedFragmentsRule.mjs\"; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from \"./rules/PossibleFragmentSpreadsRule.mjs\"; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from \"./rules/NoFragmentCyclesRule.mjs\"; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from \"./rules/UniqueVariableNamesRule.mjs\"; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from \"./rules/NoUndefinedVariablesRule.mjs\"; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from \"./rules/NoUnusedVariablesRule.mjs\"; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from \"./rules/KnownDirectivesRule.mjs\"; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from \"./rules/UniqueDirectivesPerLocationRule.mjs\"; // Spec Section: \"Argument Names\"\n\nimport { KnownArgumentNamesRule, KnownArgumentNamesOnDirectivesRule } from \"./rules/KnownArgumentNamesRule.mjs\"; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from \"./rules/UniqueArgumentNamesRule.mjs\"; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from \"./rules/ValuesOfCorrectTypeRule.mjs\"; // Spec Section: \"Argument Optionality\"\n\nimport { ProvidedRequiredArgumentsRule, ProvidedRequiredArgumentsOnDirectivesRule } from \"./rules/ProvidedRequiredArgumentsRule.mjs\"; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from \"./rules/VariablesInAllowedPositionRule.mjs\"; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from \"./rules/OverlappingFieldsCanBeMergedRule.mjs\"; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from \"./rules/UniqueInputFieldNamesRule.mjs\"; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from \"./rules/LoneSchemaDefinitionRule.mjs\";\nimport { UniqueOperationTypesRule } from \"./rules/UniqueOperationTypesRule.mjs\";\nimport { UniqueTypeNamesRule } from \"./rules/UniqueTypeNamesRule.mjs\";\nimport { UniqueEnumValueNamesRule } from \"./rules/UniqueEnumValueNamesRule.mjs\";\nimport { UniqueFieldDefinitionNamesRule } from \"./rules/UniqueFieldDefinitionNamesRule.mjs\";\nimport { UniqueDirectiveNamesRule } from \"./rules/UniqueDirectiveNamesRule.mjs\";\nimport { PossibleTypeExtensionsRule } from \"./rules/PossibleTypeExtensionsRule.mjs\";\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport var specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule]);\n/**\n * @internal\n */\n\nexport var specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\nexport function UniqueOperationNamesRule(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new GraphQLError(\"There can be only one operation named \\\"\".concat(operationName.value, \"\\\".\"), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\nexport function LoneAnonymousOperationRule(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new GraphQLError('This anonymous operation must be the only defined operation.', node));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new GraphQLError(node.name ? \"Subscription \\\"\".concat(node.name.value, \"\\\" must select only one top level field.\") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          var typeStr = print(typeCondition);\n          context.reportError(new GraphQLError(\"Fragment cannot condition on non composite type \\\"\".concat(typeStr, \"\\\".\"), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        var typeStr = print(node.typeCondition);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(node.name.value, \"\\\" cannot condition on non composite type \\\"\").concat(typeStr, \"\\\".\"), node.typeCondition));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isInputType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.type);\n\n      if (type && !isInputType(type)) {\n        var variableName = node.variable.name.value;\n        var typeName = print(node.type);\n        context.reportError(new GraphQLError(\"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\"), node.type));\n      }\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { getNamedType, isLeafType } from \"../../type/definition.mjs\";\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            var fieldName = node.name.value;\n            var typeStr = inspect(type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since type \\\"\").concat(typeStr, \"\\\" has no subfields.\"), selectionSet));\n          }\n        } else if (!selectionSet) {\n          var _fieldName = node.name.value;\n\n          var _typeStr = inspect(type);\n\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(_fieldName, \"\\\" of type \\\"\").concat(_typeStr, \"\\\" must have a selection of subfields. Did you mean \\\"\").concat(_fieldName, \" { ... }\\\"?\"), node));\n        }\n      }\n    }\n  };\n}\n","import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\nexport function UniqueFragmentNamesRule(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new GraphQLError(\"There can be only one fragment named \\\"\".concat(fragmentName, \"\\\".\"), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { doTypesOverlap } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new GraphQLError(\"There can be only one variable named \\\"$\".concat(variableName, \"\\\".\"), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\nexport function NoUndefinedVariablesRule(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\"), [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\nexport function NoUnusedVariablesRule(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {\n          var variableDef = _variableDefs2[_i4];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(variableName, \"\\\" is never used in operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(variableName, \"\\\" is never used.\"), variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nimport { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ASTValidationContext = /*#__PURE__*/function () {\n  function ASTValidationContext(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._onError(error);\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  _proto.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {\n          var selection = _set$selections2[_i2];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n\n        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {\n          var spread = _this$getFragmentSpre2[_i4];\n          var fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  return ASTValidationContext;\n}();\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast, onError) || this;\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {\n        var frag = _this$getRecursivelyR2[_i6];\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  _proto3.getEnumValue = function getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n","import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n","import invariant from \"../../../jsutils/invariant.mjs\";\nimport { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType, isInputObjectType } from \"../../../type/definition.mjs\";\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var fieldDef = context.getFieldDef();\n      var deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        var parentType = context.getParentType();\n        parentType != null || invariant(0);\n        context.reportError(new GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated. \").concat(deprecationReason), node));\n      }\n    },\n    Argument: function Argument(node) {\n      var argDef = context.getArgument();\n      var deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        var directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n        } else {\n          var parentType = context.getParentType();\n          var fieldDef = context.getFieldDef();\n          parentType != null && fieldDef != null || invariant(0);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(parentType.name, \".\").concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        var inputFieldDef = inputObjectDef.getFields()[node.name.value]; // flowlint-next-line unnecessary-optional-chain:off\n\n        var deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(new GraphQLError(\"The input field \".concat(inputObjectDef.name, \".\").concat(inputFieldDef.name, \" is deprecated. \").concat(deprecationReason), node));\n        }\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var enumValueDef = context.getEnumValue();\n      var deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        var enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(0);\n        context.reportError(new GraphQLError(\"The enum value \\\"\".concat(enumTypeDef.name, \".\").concat(enumValueDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n      }\n    }\n  };\n}\n","import { C as CodeMirror } from \"./codemirror.es.js\";\nimport { Kind, specifiedRules, NoUnusedFragmentsRule, ExecutableDefinitionsRule, KnownFragmentNamesRule, validate, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, print, parse, NoDeprecatedCustomRule } from \"graphql\";\nimport { o as onlineParser } from \"./types.es.js\";\nimport { R as Range, P as Position, C as CharacterStream } from \"./Range.es.js\";\nimport \"./index.es.js\";\nimport \"react\";\nimport \"react-dom\";\nconst specifiedSDLRules = [\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule\n];\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = specifiedRules.filter((rule) => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors = validate(schema, ast, rules);\n  return errors.filter((error) => {\n    if (error.message.indexOf(\"Unknown directive\") !== -1 && error.nodes) {\n      const node = error.nodes[0];\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name = node.name.value;\n        if (name === \"arguments\" || name === \"argumentDefinitions\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\nconst SEVERITY$1 = {\n  Error: \"Error\",\n  Warning: \"Warning\",\n  Information: \"Information\",\n  Hint: \"Hint\"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  let ast = null;\n  if (externalFragments) {\n    if (typeof externalFragments === \"string\") {\n      query += \"\\n\\n\" + externalFragments;\n    } else {\n      query += \"\\n\\n\" + externalFragments.reduce((agg, node) => {\n        agg += print(node) + \"\\n\\n\";\n        return agg;\n      }, \"\");\n    }\n  }\n  try {\n    ast = parse(query);\n  } catch (error) {\n    const range = getRange(error.locations[0], query);\n    return [\n      {\n        severity: DIAGNOSTIC_SEVERITY.Error,\n        message: error.message,\n        source: \"GraphQL: Syntax\",\n        range\n      }\n    ];\n  }\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nfunction validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, \"Validation\"));\n  const deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, \"Deprecation\"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error.nodes.forEach((node) => {\n    const highlightNode = node.kind !== \"Variable\" && \"name\" in node && node.name !== void 0 ? node.name : \"variable\" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant(error.locations, \"GraphQL validation error requires locations.\");\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\nfunction getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split(\"\\n\");\n  invariant(lines.length >= location.line, \"Query text must have more lines than where the error happened\");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === \"invalidchar\") {\n        break;\n      }\n    }\n  }\n  invariant(stream, \"Expected Parser stream to be available.\");\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, \"Expected ASTNode to have a location.\");\n  return location;\n}\nconst SEVERITY = [\"error\", \"warning\", \"information\", \"hint\"];\nconst TYPE = {\n  \"GraphQL: Validation\": \"validation\",\n  \"GraphQL: Deprecation\": \"deprecation\",\n  \"GraphQL: Syntax\": \"syntax\"\n};\nCodeMirror.registerHelper(\"lint\", \"graphql\", (text, options) => {\n  const schema = options.schema;\n  const rawResults = getDiagnostics(text, schema, options.validationRules, void 0, options.externalFragments);\n  const results = rawResults.map((error) => ({\n    message: error.message,\n    severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n    type: error.source ? TYPE[error.source] : void 0,\n    from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n    to: CodeMirror.Pos(error.range.end.line, error.range.end.character)\n  }));\n  return results;\n});\n"],"names":["CharacterStream","constructor","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whitespaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","setStart","Position","setEnd","lessThanOrEqualTo","setLine","setCharacter","ExecutableDefinitionsRule","context","Document","node","_i2","_node$definitions2","definitions","definition","defName","kind","name","value","reportError","GraphQLError","concat","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","push","FragmentDefinition","leave","fragmentNameUsed","Object","create","operation","_i4","_context$getRecursive2","getRecursivelyReferencedFragments","_i6","fragmentDef","fragName","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","target","i","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","configurable","writable","KnownArgumentNamesOnDirectivesRule","directiveArgs","schema","getSchema","definedDirectives","getDirectives","directive","args","map","arg","astDefinitions","getDocument","def","_def$arguments","argsNodes","Directive","directiveNode","directiveName","knownArgs","_directiveNode$argume2","argNode","argName","indexOf","suggestions","suggestionList","didYouMean","isValidValueNode","locationType","getInputType","type","undefined","parseLiteral","_typeStr","inspect","error","_typeStr2","message","typeStr","ProvidedRequiredArgumentsOnDirectivesRule","requiredArgsMap","keyMap","argNodes","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","_argNodes","argNodeMap","_i8","_Object$keys2","argType","argTypeStr","defaultValue","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","ofType","reasonMessage","reason","isArray","_ref","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","collectConflictsBetweenFragments","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","j","parentFieldsAreMutuallyExclusive","_i7","fields2","fields1","conflict","findConflict","field1","field2","parentType1","node1","def1","parentType2","node2","def2","_node1$arguments","_node2$arguments","name1","name2","arguments1","arguments2","every","argument1","value1","value2","argument2","find","argument","sameArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","_getFieldsAndFragment2","getFieldsAndFragmentNames","_getFieldsAndFragment3","_i3","_j","findConflictsBetweenSubSelectionSets","_ref6","reduce","allFields","_ref7","_ref8","subfieldConflicts","parentType","cached","get","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","set","fragmentType","typeFromAST","typeCondition","_i9","_selectionSet$selecti2","selections","selection","fieldName","fieldDef","getFields","alias","inlineFragmentType","PairSet","_data","_proto","prototype","a","b","first","result","_pairSetAdd","specifiedRules","freeze","knownOperationNames","operationName","operationCount","KnownTypeNamesRule","InlineFragment","VariableDefinition","variableName","variable","typeName","Field","getType","_fieldName","getParentType","getFieldDef","suggestion","suggestedTypes","Set","usageCount","_schema$getPossibleTy2","getPossibleTypes","possibleType","_possibleType$getInte2","getInterfaces","_usageCount$possibleI","possibleInterface","arrayFrom","sort","typeA","typeB","usageCountDiff","isSubType","naturalCompare","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","s","pop","knownVariableNames","variableNameDefined","enter","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","_variableDefs2","variableDef","KnownDirectivesRule","UniqueDirectivesPerLocationRule","Argument","argDef","getArgument","knownArgsNames","UniqueArgumentNamesRule","ListValue","getParentInputType","ObjectValue","fieldNodeMap","fields","field","_objectValues2","objectValues","ObjectField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","fieldNode","_fieldNode$arguments","_fieldDef$args2","varDefMap","_ref2","varDef","varTypeStr","Map","SelectionSet","_getFieldsAndFragment","_i5","_objectEntries2","objectEntries","_ref5","collectConflictsWithin","findConflictsWithinSelectionSet","_ref3","_ref2$","reasonMsg","UniqueInputFieldNamesRule","LoneSchemaDefinitionRule","UniqueOperationTypesRule","UniqueTypeNamesRule","UniqueEnumValueNamesRule","UniqueFieldDefinitionNamesRule","UniqueDirectiveNamesRule","PossibleTypeExtensionsRule","_inheritsLoose","subClass","superClass","__proto__","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","fragments","frags","statement","spreads","setsToVisit","_set$selections2","collectedNames","nodesToVisit","_this$getFragmentSpre2","ValidationContext","_ASTValidationContext2","typeInfo","_this2","call","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","_proto3","getVariableUsages","newUsages","TypeInfo","Variable","getDefaultValue","_this$getRecursivelyR2","getDirective","getEnumValue","documentAST","rules","options","maxErrors","devAssert","abortObj","errors","visitor","rule","e","NoDeprecatedCustomRule","deprecationReason","invariant","directiveDef","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","query","customRules","isRelayCompatMode","externalFragments","agg","range","location","queryText","parser","o","state","startState","lines","split","stream","C","R","P","getRange","locations","severity","validationErrorAnnotations","mapCat","isSchemaDocument","nodes","validateWithCustomRules","annotations","deprecationWarningAnnotations","Warning","validateQuery","array","mapper","highlightedNodes","highlightNode","loc","highlightLoc","getLocation","SEVERITY","TYPE","text","validationRules","from","to"],"sourceRoot":""}