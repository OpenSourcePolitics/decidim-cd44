{"version":3,"file":"js/1441-ba82d88f9a21a015e2b2.chunk.js","mappings":"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","sources":["webpack://app/./node_modules/@graphiql/react/dist/Range.es.js","webpack://app/./node_modules/@graphiql/react/dist/hint.es.js"],"sourcesContent":["class CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match && match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\nexport { CharacterStream as C, Position as P, Range as R };\n","import { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat, o as onlineParser } from \"./types.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"./index.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = (op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n};\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = (field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n};\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\nconst getParentDefinition = (state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n};\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\nfunction canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = state.prevState && state.prevState.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = state.prevState && state.prevState.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef && argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if (results && results.list && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n"],"names":["CharacterStream","constructor","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whitespaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","setStart","Position","setEnd","lessThanOrEqualTo","setLine","setCharacter","getFieldDef","schema","type","fieldName","S","getQueryType","T","getFields","forEachState","stack","fn","reverseStateStack","state","kind","push","prevState","i","objectValues","object","keys","Object","len","values","hintList","list","text","filterNonEmpty","entry","isDeprecated","map","proximity","getProximity","normalizeText","label","pair","sort","a","b","filterAndSortList","string","array","predicate","filtered","filter","toLowerCase","replace","suggestion","j","d","aLength","bLength","cost","Math","min","lexicalDistance","indexOf","SuggestionCommand","command","title","getAutocompleteSuggestions","queryText","cursor","contextToken","fragmentDefs","options","_a","opts","assign","styleAtCursor","stateAtCursor","stringAtCursor","runOnlineParser","stream","style","index","getTokenAtPosition","step","typeInfo","tokenState","argDef","argDefs","directiveDef","enumValue","fieldDef","inputType","objectTypeDef","objectFieldDefs","parentType","interfaceDef","R","getMutationType","getSubscriptionType","getType","name","getDirective","interfaces","fields","args","field","enumType","getValues","find","val","value","nullableType","ofType","objectType","objectField","getTypeInfo","C","documentText","needsSeperator","schemaInterfaces","getTypeMap","schemaInterfaceNames","inlineInterfaces","Set","_","_b","_c","_d","_e","includes","add","getInterfaces","interfaceConfig","toConfig","objectTypeConfig","currentTypeToExtend","siblingInterfaceNames","possibleInterfaces","concat","result","description","documentation","getSuggestionsForImplements","_a2","sortText","String","detail","deprecated","Boolean","deprecationReason","insertText","insertSuffix","getInsertText","insertTextFormat","I","getSuggestionsForFieldNames","objectFields","completionKind","namedInputType","queryVariables","getVariableCompletions","v","getSuggestionsForInputValues","_kind","possibleTypes","abstractType","possibleObjTypes","getPossibleTypes","possibleIfaceMap","create","forEach","iface","namedType","getSuggestionsForFragmentTypeConditions","typeMap","defState","definitionState","getDefinitionState","fragments","selectionSet","selections","typeCondition","getFragmentDefinitions","relevantFrags","frag","getSuggestionsForFragmentSpread","isArray","op","externalFragments","FragmentDefinition","def","collectFragmentDefs","inputTypes","getSuggestionsForVariableDefinition","directives","getDirectives","directive","locations","canUseDirective","getSuggestionsForDirective","variableType","variableName","definitions","parentDefinition","_f","_g","_h","_j","_k","getParentDefinition","toString","callback","lines","split","parser","o","startState","editor","cur","getCursor","getTokenAt","tokenStart","P","results","getValue","item","from","ch","to"],"sourceRoot":""}